/*
 *  Copyright (C) 2010 Andres Grino Brandt <agrinob@hotmail.com>
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package jcobol.parser.antlr;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import jcobol.filter.TokenFilterByText;
import jcobol.filter.TokenFilterByType;
import jcobol.lexer.CobolToken;
import jcobol.lexer.CobolType;
import jcobol.lexer.TokenList;

/**
 * Convert and select lists of CobolToken to AntlrCobolToken.
 * <p>Convertions are:
 * <ul>
 * <li>Discard all COMMA and SEMI-COLON tokens.
 * <li>Discard all non-code tokens (COMMENT, NEW_PAGE and SPECIAL_LINE).
 * <li>For cobol keyword with synonym (PICTURE/PIC, JUSTIFIED/JUST, etc.),
 * use the same ANTLR type for both. Always choose the type for the shorter form.
 * </ul>
 * @author Andr&eacute;s Gri&ntilde;&oacute; Brandt <agrinob@hotmail.com>
 */
public class TokenFactory {

    private final Properties tokenDictionary;
    private final TokenFilterByType filterType;
    private final TokenFilterByText filterText;

    /**
     * Constructor.
     *
     * @param tokenDictionary The properties file generated by antlr
     * for the parser. For a grammar X, the file name is X.tokens
     */
    public TokenFactory(Properties tokenDictionary) {
        this.tokenDictionary = tokenDictionary;
        this.filterType = new TokenFilterByType();
        this.filterType.addType(CobolType.COMMENT, false);
        this.filterType.addType(CobolType.NEW_PAGE, false);
        this.filterType.addType(CobolType.SPECIAL_LINE, false);
        this.filterText = new TokenFilterByText();
        this.filterText.addText(",", false);
        this.filterText.addText(";", false);
    }

    public List<AntlrCobolToken> getTokens(final TokenList tokens) {
        TokenList listTokens = tokens.get(filterType, filterText);
        List<AntlrCobolToken> list = new ArrayList<AntlrCobolToken>(listTokens.size());
        for (int i = 0; i < listTokens.size(); i++) {
            CobolToken ct = listTokens.get(i);
            list.add(new AntlrCobolToken(ct, list.size(), getTypeFor(ct)));
        }
        return list;
    }

    public List<AntlrCobolToken> getTokens(final TokenList tokens, final String divisionName) {

        List<CobolToken> division = selectDivision(tokens.get(filterType, filterText), divisionName);
        List<AntlrCobolToken> list = new ArrayList<AntlrCobolToken>();
        for (CobolToken ct : division) {
            list.add(new AntlrCobolToken(ct, list.size(), getTypeFor(ct)));
        }
        return list;
    }

    private List<CobolToken> selectDivision(final TokenList tokens, final String divisionName) {

        int start = tokens.getIndexIgnoreCase(0, divisionName);
        int stop = -1;

        if (start >= 0) {
            stop = tokens.getIndexIgnoreCase(start + 2, "DIVISION");
            if (stop == -1) {
                stop = tokens.size() - 1;
            } else {
                int lineNumber = tokens.get(stop).getRow();
                while (stop >= 0 && tokens.get(stop).getRow() == lineNumber) {
                    stop--;
                }
            }
        }

        return (start > -1 && start <= stop) ? tokens.subList(start, stop + 1) : new ArrayList<CobolToken>();
    }

    /**
     * For a given token, determines the type as needed by the antlr parser.
     * @param token The original cobol token.
     * @return The type extracted from X.tokens (via Properties).
     */
    private int getTypeFor(final CobolToken token) {
        String value = null;
        String correct = null;
        CobolType originalType = token.getType();
        String content = token.getText();
        switch (originalType) {
            case WORD:
                /*  WORD includes keywords (like PERFORM) and data names.
                 *  For keywords, the type is specific; for data names,
                 *  the type is always generic (WORD).
                 */

                //  Antlr names use "_" instead of Cobol's "-".
                //  Antlr grammar always use uppercase.
                if (content.equals("-")) {
                    //  Single hypen.
                    correct = content;
                }
                else {
                    correct = content.replace('-', '_').toUpperCase();
                    }

                /**
                 * Synonyms:
                 * THROUGH same type as THRU
                 * AREAS same type as AREA.
                 * Operators:
                 * '+' -> Use 'OP_PLUS' to search in the dictionary.
                 * '-' -> Use 'OP_MINUS' ...
                 */
                char first = correct.charAt(0);
                if (!Character.isDigit(first)) {
                    correct = (Character.isLetter(first)) ? getSynonym(correct) : getTextForOperator(correct);
                    }

                value = tokenDictionary.getProperty(correct);
                if (value == null) {
                    value = tokenDictionary.getProperty("WORD");
                }
                break;
            case SEPARATOR:
                if (content.equals(".")) {
                    value = tokenDictionary.getProperty("PERIOD");
                }
                if (content.equals(",")) {
                    value = tokenDictionary.getProperty("COMMA_SEP");
                }
                if (content.equals(";")) {
                    value = tokenDictionary.getProperty("SEMICOLON_SEP");
                }
                break;
            default:
                String key = originalType.toString();
                value = tokenDictionary.getProperty(key);
                break;
        }
        assert value != null : "Type not found for text='" + content + "'";
        return Integer.parseInt(value);
    }

    private String getTextForOperator(final String op) {
        if (op.equals("+"))  return "OP_PLUS";
        if (op.equals("-"))  return "OP_MINUS";
        if (op.equals("*"))  return "OP_MUL";
        if (op.equals("/"))  return "OP_DIV";
        if (op.equals("**")) return "OP_EXP";
        if (op.equals("<"))  return "OP_LESS";
        if (op.equals("<=")) return "OP_LESS_EQUAL";
        if (op.equals(">"))  return "OP_GREATER";
        if (op.equals(">=")) return "OP_GREATER_EQUAL";
        if (op.equals("="))  return "OP_EQUAL";
        return op;
    }

    private static final Map<String, String> synonyms = new HashMap<String, String>();
    static {
        synonyms.put("THROUGH",     "THRU");
        synonyms.put("AREAS",       "AREA");
        synonyms.put("ARE",         "IS");
        synonyms.put("RECORDS",     "RECORD");
        synonyms.put("ZEROS",       "ZERO");
        synonyms.put("ZEROES",      "ZERO");
        synonyms.put("JUSTIFIED",   "JUST");
        synonyms.put("PICTURE",     "PIC");
        synonyms.put("SYNCHRONIZED","SYNC");
        synonyms.put("VALUES",      "VALUE");
        synonyms.put("SPACES",      "SPACE");
        synonyms.put("HIGH_VALUES", "HIGH_VALUE");
        synonyms.put("LOW_VALUES",  "LOW_VALUE");
        synonyms.put("QUOTES",      "QUOTE");
        synonyms.put("NULLS",       "NULL");
        synonyms.put("COMPUTATIONAL", "COMP");
        synonyms.put("COMPUTATIONAL_1", "COMP_1");
        synonyms.put("COMPUTATIONAL_2", "COMP_2");
        synonyms.put("COMPUTATIONAL_3", "COMP_3");
        synonyms.put("COMPUTATIONAL_4", "COMP_4");
        synonyms.put("COMPUTATIONAL_5", "COMP_5");
        synonyms.put("COMPUTATIONAL_6", "COMP_6");
        synonyms.put("IDENTIFICATION",  "ID");
        synonyms.put("BACKGROUND-COLOR", "BACKGROUND");
        synonyms.put("FOREGROUND-COLOR", "FOREGROUND");
        synonyms.put("AUTO-SKIP",        "AUTO");
        synonyms.put("COLUMN",           "COL");
        synonyms.put("IDENTIFICATION",  "ID");
        synonyms.put("REPORTS",         "REPORT");
        synonyms.put("CONTROLS",        "CONTROL");
        synonyms.put("LINES",           "LINE");
    }
    private String getSynonym(final String keyword) {
        String correct = synonyms.get(keyword);
        return (correct != null) ? correct : keyword;
    }

}
